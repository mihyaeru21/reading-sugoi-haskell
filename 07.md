7. 型や型クラスを自分で作ろう
=============================

## 7.1 新しいデータ型を定義する
- `data`キーワード
    - `data Bool = False | True`

## 7.2 形づくる
- 値コンストラクタ
- `deriving`でとりあえず`Show`できるようになるらしい
- `Shape(..)`で`Shape`の全ての値コンストラクタをエクスポートできる
- カッコを付けないとことで何も値コンストラクタをエクスポートしないようにもできる

## 7.3 レコード構文
- フィールドの型名の代わりに中括弧でくくって名前つけれる
    - `data Person = Person { hoge :: String }`
    - `hoge :: Person -> String`という関数を自動で作ってくれる
    - `Person { hoge = "aaa" }`

## 7.4 型引数
- `Maybe`先輩
- 型クラス制約はデータ宣言には付けない！
    - 関数の型宣言でどのみち型クラス制約をつける
- 型コンストラクタと値コンストラクタは完全に別物
    - `data Vector a = Vector a a a`
    - 左側の`Vector a`が型コンストラクタ
    - 右側の`Vector a a a`が値コンストラクタ
- 関数の型宣言を書くときは、型コンストラクタの方を使う

## 7.5 インスタンスの自動導出
- 一部の型クラスは`deriving`で自動導出できる
- `Eq`を自動導出すると、全てのフィールドを比較してくれる
- `Show`, `Read`も全てのフィールドが属していれば自動導出できる
- `Ord`は、値コンストラクタが定義されている順番でも比較される
- 値コンストラクタが全て引数を取らない場合は`Enum`型クラスを自動導出できる

## 7.6 型シノニム
- `[Char]`と`String`のようだ
- 多層型にも名前をつけれる`type Hoge = [Int]`
- 値コンストラクタは生成されないぞ！
- 型の領域と値の領域を意識せよ
- `Eighter`出てきた
    - `Maybe`よりも汎用的に使える

## 7.7 再帰的なデータ構造
- 独自リストを作ってみる
- 演算子として定義する関数とか値コンストラクタの結合性を指定できる
    - `infixl`
    - `infixr`
    - デフォルトでは`infixl 9`
- パターンマッチは実は値コンストラクタをマッチさせるのだ

## 7.8 型クラス 中級講座
- 型クラスを作るよ
- 最小完全定義
- `:i Maybe`とかで何のインスタンスになっているかわかる

## 7.9 YesとNoの型クラス
- Bool値として評価できる感じにする`YesNo`型クラスを作って、既存の型をそれに対応させる

## 7.10 Functor型クラス
- コンテナっぽい型コンストラクタに対するmapって感じ
    - `[]`
    - `Maybe`
    - etc...

## 7.11 型を司るもの、種類
- 型の型っぽいやつが`kind`
- `:k Int`で見れる

