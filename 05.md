5 高階関数
==========

## 5.1 カリー化関数
- 全ての関数は実は引数は1個だけとる
- 本来より少ない引数で関数を呼び出すと部分適用
- 中置関数は`(/10)`とか`(10/)`で部分適用できる
- カリー化関数と部分適用は超重要なんや

## 5.2 高階実演
- `->`は右結合
- 高階関数を書いていて型がわからなくなったら、とりあえず書いて`:t`すればおｋ

## 5.3 関数プログラマの道具箱
- `map`さん
- もちろん`filter`氏も
- `map`に2引数の関数を渡した場合、部分適用された関数のリストになる
    - 特別なことは何もなくて、2引数の関数に1引数だけ渡すからこういう挙動になる

## 5.4 ラムダ式
- `\`を思いっきり目を細めると`λ`に見える
    - 見えない
- カリー化と部分適用の理解が浅いと無駄にラムダを使ってしまう
    - `map (+3) [1, 2, 3]`
    - `map (\x -> x + 3) [1, 2, 3]`
    - ラムダ式でパターンマッチが失敗するとランタイムエラー

## 5.5 畳み込み、見込みアリ！
- `foldl`, `foldr`
- リストを走査して何かを返すときは畳み込みを使うことを考える
- リストから新しいリストを作るときは右畳み込みを使うのが一般的
    - `++`よりも`:`の方が遥かに高速だから
- `foldl1`, `foldr1`
    - 初期値をリストの先頭、末尾から使う
    - カラリストだとランタイムエラー
- 畳み込みを作るときはカラリストの場合を考慮する
- 標準関数を実装
- 右: `f 1 (f 2 (f 3 (f 4)))`
- 左: `f (f (f (f 1) 2) 3) 4`
- `foldr`は`f x _`なパターンがある関数なら無限リストに使っても停止しうる

## 5.6 $を使った関数適用
- `$`関数
- 普通の関数適用は左結合
- `$`の関数適用は右結合
- 遥か右の彼方に`)`がある`(`という感じ
    - `sum (filter (> 10) (map (*2) [1..]))`
    - `sum $ filter (> 10) $ map (*2) [1..]`
- `$`に1引数`a`を与えると、関数`f`を受け取って`f a`する感じの関数になる

## 5.7 関数合成
- `.`関数を使う
- `.`は右結合
    - `f (g (z x))` == `(f . g . z) x`
- 他引数関数でも1引数になるまで部分適用すれば合成できる

